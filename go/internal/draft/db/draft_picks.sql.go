// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: draft_picks.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const claimNextPickSlot = `-- name: ClaimNextPickSlot :one
SELECT dp.id, dp.team_id, dp.overall_pick
FROM draft_picks dp
WHERE dp.draft_id = $1
  AND dp.player_id IS NULL
ORDER BY dp.overall_pick
FOR UPDATE SKIP LOCKED
LIMIT 1
`

type ClaimNextPickSlotRow struct {
	ID          uuid.UUID `json:"id"`
	TeamID      uuid.UUID `json:"team_id"`
	OverallPick int32     `json:"overall_pick"`
}

func (q *Queries) ClaimNextPickSlot(ctx context.Context, draftID uuid.UUID) (ClaimNextPickSlotRow, error) {
	row := q.db.QueryRowContext(ctx, claimNextPickSlot, draftID)
	var i ClaimNextPickSlotRow
	err := row.Scan(&i.ID, &i.TeamID, &i.OverallPick)
	return i, err
}

const countRemainingPicks = `-- name: CountRemainingPicks :one
SELECT COUNT(*) FROM draft_picks
WHERE draft_id = $1 AND player_id IS NULL
`

func (q *Queries) CountRemainingPicks(ctx context.Context, draftID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRemainingPicks, draftID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDraftPick = `-- name: CreateDraftPick :one
INSERT INTO draft_picks (
    id,
    draft_id,
    round,
    pick,
    overall_pick,
    team_id,
    player_id,
    picked_at,
    auction_amount,
    keeper_pick
) VALUES (
    $1, -- id
    $2, -- draft_id
    $3, -- round
    $4, -- pick
    $5, -- overall_pick
    $6, -- team_id
    $7, -- player_id
    $8, -- picked_at
    $9, -- auction_amount
    $10 -- keeper_pick
) RETURNING id, draft_id, round, pick, overall_pick, team_id, player_id, picked_at, auction_amount, keeper_pick
`

type CreateDraftPickParams struct {
	ID            uuid.UUID      `json:"id"`
	DraftID       uuid.UUID      `json:"draft_id"`
	Round         int32          `json:"round"`
	Pick          int32          `json:"pick"`
	OverallPick   int32          `json:"overall_pick"`
	TeamID        uuid.UUID      `json:"team_id"`
	PlayerID      uuid.NullUUID  `json:"player_id"`
	PickedAt      sql.NullTime   `json:"picked_at"`
	AuctionAmount sql.NullString `json:"auction_amount"`
	KeeperPick    sql.NullBool   `json:"keeper_pick"`
}

func (q *Queries) CreateDraftPick(ctx context.Context, arg CreateDraftPickParams) (DraftPick, error) {
	row := q.db.QueryRowContext(ctx, createDraftPick,
		arg.ID,
		arg.DraftID,
		arg.Round,
		arg.Pick,
		arg.OverallPick,
		arg.TeamID,
		arg.PlayerID,
		arg.PickedAt,
		arg.AuctionAmount,
		arg.KeeperPick,
	)
	var i DraftPick
	err := row.Scan(
		&i.ID,
		&i.DraftID,
		&i.Round,
		&i.Pick,
		&i.OverallPick,
		&i.TeamID,
		&i.PlayerID,
		&i.PickedAt,
		&i.AuctionAmount,
		&i.KeeperPick,
	)
	return i, err
}

const createDraftPickBatch = `-- name: CreateDraftPickBatch :exec
INSERT INTO draft_picks (
    id,
    draft_id,
    round,
    pick,
    overall_pick,
    team_id
) 
SELECT 
    unnest($1::uuid[]) as id,
    unnest($2::uuid[]) as draft_id,
    unnest($3::integer[]) as round,
    unnest($4::integer[]) as pick,
    unnest($5::integer[]) as overall_pick,
    unnest($6::uuid[]) as team_id
`

type CreateDraftPickBatchParams struct {
	Column1 []uuid.UUID `json:"column_1"`
	Column2 []uuid.UUID `json:"column_2"`
	Column3 []int32     `json:"column_3"`
	Column4 []int32     `json:"column_4"`
	Column5 []int32     `json:"column_5"`
	Column6 []uuid.UUID `json:"column_6"`
}

func (q *Queries) CreateDraftPickBatch(ctx context.Context, arg CreateDraftPickBatchParams) error {
	_, err := q.db.ExecContext(ctx, createDraftPickBatch,
		pq.Array(arg.Column1),
		pq.Array(arg.Column2),
		pq.Array(arg.Column3),
		pq.Array(arg.Column4),
		pq.Array(arg.Column5),
		pq.Array(arg.Column6),
	)
	return err
}

const deleteDraftPicksByDraft = `-- name: DeleteDraftPicksByDraft :exec
DELETE FROM draft_picks WHERE draft_id = $1
`

func (q *Queries) DeleteDraftPicksByDraft(ctx context.Context, draftID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteDraftPicksByDraft, draftID)
	return err
}

const getDraftPick = `-- name: GetDraftPick :one
SELECT id, draft_id, round, pick, overall_pick, team_id, player_id, picked_at, auction_amount, keeper_pick FROM draft_picks WHERE id = $1
`

func (q *Queries) GetDraftPick(ctx context.Context, id uuid.UUID) (DraftPick, error) {
	row := q.db.QueryRowContext(ctx, getDraftPick, id)
	var i DraftPick
	err := row.Scan(
		&i.ID,
		&i.DraftID,
		&i.Round,
		&i.Pick,
		&i.OverallPick,
		&i.TeamID,
		&i.PlayerID,
		&i.PickedAt,
		&i.AuctionAmount,
		&i.KeeperPick,
	)
	return i, err
}

const getDraftPicksByDraft = `-- name: GetDraftPicksByDraft :many
SELECT id, draft_id, round, pick, overall_pick, team_id, player_id, picked_at, auction_amount, keeper_pick FROM draft_picks 
WHERE draft_id = $1 
ORDER BY overall_pick
`

func (q *Queries) GetDraftPicksByDraft(ctx context.Context, draftID uuid.UUID) ([]DraftPick, error) {
	rows, err := q.db.QueryContext(ctx, getDraftPicksByDraft, draftID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DraftPick
	for rows.Next() {
		var i DraftPick
		if err := rows.Scan(
			&i.ID,
			&i.DraftID,
			&i.Round,
			&i.Pick,
			&i.OverallPick,
			&i.TeamID,
			&i.PlayerID,
			&i.PickedAt,
			&i.AuctionAmount,
			&i.KeeperPick,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDraftPicksByRound = `-- name: GetDraftPicksByRound :many
SELECT id, draft_id, round, pick, overall_pick, team_id, player_id, picked_at, auction_amount, keeper_pick FROM draft_picks 
WHERE draft_id = $1 AND round = $2 
ORDER BY pick
`

type GetDraftPicksByRoundParams struct {
	DraftID uuid.UUID `json:"draft_id"`
	Round   int32     `json:"round"`
}

func (q *Queries) GetDraftPicksByRound(ctx context.Context, arg GetDraftPicksByRoundParams) ([]DraftPick, error) {
	rows, err := q.db.QueryContext(ctx, getDraftPicksByRound, arg.DraftID, arg.Round)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DraftPick
	for rows.Next() {
		var i DraftPick
		if err := rows.Scan(
			&i.ID,
			&i.DraftID,
			&i.Round,
			&i.Pick,
			&i.OverallPick,
			&i.TeamID,
			&i.PlayerID,
			&i.PickedAt,
			&i.AuctionAmount,
			&i.KeeperPick,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextPickForDraft = `-- name: GetNextPickForDraft :one
SELECT id, draft_id, round, pick, overall_pick, team_id, player_id, picked_at, auction_amount, keeper_pick FROM draft_picks 
WHERE draft_id = $1 AND player_id IS NULL 
ORDER BY overall_pick 
LIMIT 1
`

func (q *Queries) GetNextPickForDraft(ctx context.Context, draftID uuid.UUID) (DraftPick, error) {
	row := q.db.QueryRowContext(ctx, getNextPickForDraft, draftID)
	var i DraftPick
	err := row.Scan(
		&i.ID,
		&i.DraftID,
		&i.Round,
		&i.Pick,
		&i.OverallPick,
		&i.TeamID,
		&i.PlayerID,
		&i.PickedAt,
		&i.AuctionAmount,
		&i.KeeperPick,
	)
	return i, err
}

const makePick = `-- name: MakePick :execrows
UPDATE draft_picks
SET player_id = $2, picked_at = NOW()
WHERE id = $1
  AND player_id IS NULL
`

type MakePickParams struct {
	ID       uuid.UUID     `json:"id"`
	PlayerID uuid.NullUUID `json:"player_id"`
}

func (q *Queries) MakePick(ctx context.Context, arg MakePickParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, makePick, arg.ID, arg.PlayerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateDraftPickPlayer = `-- name: UpdateDraftPickPlayer :one
UPDATE draft_picks SET
    player_id = $2,
    picked_at = NOW(),
    auction_amount = $3,
    keeper_pick = $4
WHERE id = $1
RETURNING id, draft_id, round, pick, overall_pick, team_id, player_id, picked_at, auction_amount, keeper_pick
`

type UpdateDraftPickPlayerParams struct {
	ID            uuid.UUID      `json:"id"`
	PlayerID      uuid.NullUUID  `json:"player_id"`
	AuctionAmount sql.NullString `json:"auction_amount"`
	KeeperPick    sql.NullBool   `json:"keeper_pick"`
}

func (q *Queries) UpdateDraftPickPlayer(ctx context.Context, arg UpdateDraftPickPlayerParams) (DraftPick, error) {
	row := q.db.QueryRowContext(ctx, updateDraftPickPlayer,
		arg.ID,
		arg.PlayerID,
		arg.AuctionAmount,
		arg.KeeperPick,
	)
	var i DraftPick
	err := row.Scan(
		&i.ID,
		&i.DraftID,
		&i.Round,
		&i.Pick,
		&i.OverallPick,
		&i.TeamID,
		&i.PlayerID,
		&i.PickedAt,
		&i.AuctionAmount,
		&i.KeeperPick,
	)
	return i, err
}
